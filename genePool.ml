(*
	GenePool: A simple evolutionary algorithm library for OCaml
	by Alex Rubinsteyn (alex -dot- rubinsteyn -at- gmail -dot- com)

	Free for use under the LGPL (http://www.gnu.org/licenses/lgpl-3.0.txt)	
*)


exception GenePoolError of string

module Internal = struct
	(* returns number in range [lower, upper] which satisfies pred *)
	let goodRandom lower upper pred = 
	let satisfied = ref false in 
	let value = ref 0 in 
	let range = upper - lower + 1 in 
	while not !satisfied do 
		let rand = (Random.int range) + lower in 
		if pred rand then begin 
			satisfied := true; 
			value := rand
		end
	done;
	!value

	(* sort by first element of tuple in descending order *)
	let cmp2Descend =(fun (x1, _) (x2, _) -> -1 * (compare x1 x2))
	let cmp2Ascend =(fun (x1, _) (x2, _) ->  (compare x1 x2))


	(* int array -> (int, int) aray *)
	let tagWithIndex arr = Array.mapi (fun i x -> (x,i)) arr

	(* (int,int) array -> int array  *)
	let keepIndices arr = Array.map (fun (x,i) -> i) arr
	
	let err str = raise (GenePoolError ("GenePool: " ^ str))
	
(*
	return the maximum value of an array and its index 
*)

	let maxWithIndex arr =
	let len = Array.length arr in 
	if len < 1 then err "[maxWithIndex] Cannot get maximum of empty array"
	else 
	let maxVal = ref arr.(0) in
 	let maxIdx = ref 0 in 
	for i = 1 to len - 1 do 
		if arr.(i) > !maxVal then (maxVal := arr.(i); maxIdx:=i)
	done; 
	!maxVal, !maxIdx
 
end

open Internal 
(*
	GA Specification
	-------------------------------------------------------------------------------
		evaluate  - assign a fitness to a genome
		mutatate  - given a genome, create an altered copy
		crossover - given two genomes, combine them
		genRandom - produce a random genome from scratch
		report    - optionally output information about the best genome of each generation 
		seed      - optional initial seed population
		stop      - optional stopping predicate
 *)

type gen_number = int
   
type ('genome, 'fitness) ga_spec = {
	evaluate : gen_number -> 'genome -> 'fitness;
	mutate : gen_number -> 'genome -> 'genome;
	crossover : gen_number -> ('genome * 'genome) -> 'genome;
	genRandom: unit -> 'genome;
	seed: 'genome array option;
	report: (int -> 'genome -> 'fitness -> unit) option; 
	stop : (int -> 'genome -> 'fitness -> bool) option
}

(*
	GA Parameters
	-------------------------------------------------------------------------------
	nRandom - how many random genomes should we generate at the beginning
	nSurvivors - how many genomes survive of each generation 
	nMutations - # new genomes generated by asexual reproduction in each generation
	nCrossovers - # new genomes  by sexual reproduction in each generation 
	timeLimit - seconds until algorithm termination 
	maxGen - maximum number of generations until algorithm termination 
*)

type ga_params = {
	nRandom: int;
	nSurvivors: int;
	nMutations: int;
	nCrossovers: int;
	timeLimit:float;
	maxGen: int
}




(*
	keep top n elements of 'genomes' ranked by 'results'
	return along with max score
*)

let cull genomes results n = 
	let sortedResults = tagWithIndex results in 
	Array.fast_sort cmp2Descend sortedResults;
	let sortedIndices = keepIndices sortedResults in
	let sortedGenomes = Array.init n (fun idx -> genomes.(sortedIndices.(idx))) in 
	let maxScore, _ = sortedResults.(0) in 
	sortedGenomes, maxScore

(*
	increase a population by mutating clones and crossing between genomes
*)

let reproduce genomes nMutations nCrossovers mutate crossover gen =
	let nGenomes = Array.length genomes in  
	let total = nGenomes + nMutations + nCrossovers  in 
	let fn idx = 
		if idx < nGenomes  then genomes.(idx)
		else if idx < nGenomes + nMutations  then 
			let randIdx = Random.int nGenomes in 
		    mutate gen genomes.(randIdx)
		else 
			let idx1 = Random.int nGenomes in 
			let idx2 = Random.int nGenomes in 
			crossover gen (genomes.(idx1), genomes.(idx2))
	in Array.init total fn 

(* 
	evolveHelper
	--------------------------------------------------------------
	The heart of the evolutionary algorithm:
		- evaluate current generation fitness functions
		- report the maximum fitness 
		- cull all but the nSurvivors best genomes
		- reproduce nMutations asexually and nCrossovers sexually
		- repeat until time runs out or generations exceed maxGen 
*) 


let rec evolveHelper spec params genomes gen timeDelta finishTime =
	let currTime = Unix.gettimeofday () in 
	let timeLeft = (finishTime -. (currTime +. timeDelta)) in 
	let results = Array.map (fun g -> spec.evaluate gen g) genomes in
	let bestGenomes,  maxScore = cull  genomes results params.nSurvivors in 
	let bestGenome = bestGenomes.(0) in 
	let reportFn = 	match spec.report with Some fn -> fn | _ -> fun _ _ _ -> () in 
	reportFn gen bestGenome maxScore; 
	let keepGoing  = match spec.stop with 
		| Some fn -> not(fn gen bestGenome maxScore) 
		| None -> true in 
	if not keepGoing then print_string "[GenePool] Stopping evolution\n";
	if timeLeft > 0.0 && gen < params.maxGen && keepGoing then
		let newGenomes = reproduce bestGenomes params.nMutations params.nCrossovers spec.mutate spec.crossover gen in
		let currTime' = Unix.gettimeofday () in 
		let delta = currTime' -. currTime in 
		evolveHelper spec params newGenomes (gen+1) delta finishTime 
	else (bestGenomes, maxScore)
	
(*
	evolve
	-------------------------------------
	Wrapper for evolveHelper;
	  - check for error conditions
	  - append the given initial genomes with nRandom random genomes
	  - calculate time when algorithm should finish 
	  - call evolveHelper
*)

let evolve  spec params =
	Random.self_init();
	let userGenomes = 
		match spec.seed with None -> [| |] | Some gs -> gs in  
	let currTime = Unix.gettimeofday () in 
	let finishTime = (currTime +. params.timeLimit) in 
	let randomGenomes = Array.init params.nRandom (fun idx -> spec.genRandom ()) in 
	let genomes = Array.append userGenomes randomGenomes in
	if params.nSurvivors > Array.length genomes  then err "[evolve] nSurvivors too big"
	else evolveHelper spec params  genomes 1 0.0 finishTime 


module Utility = struct

	let selectRandom functions input  = 
		let nFunctions = Array.length functions in 
		let idx = Random.int nFunctions  in
		let fn = functions.(idx) in 
		fn input

	let randIntExcept upper bad =
		let rand = Random.int (upper - 1) in 
		if rand >= bad then rand + 1  
		else rand 

	(* return a random number which satisfies a predicate *)
	let goodRandom rng pred = 
		let satisfied = ref false in 
		let value = ref (rng ()) in 
		satisfied := pred !value; 
		let iter = ref 0 in 
		while not !satisfied  do 
			(if !iter > 1000 then raise (GenePoolError "Could not generate satisfactory random number"));
			value := rng (); 
			satisfied := pred !value;
			iter := !iter + 1;
		done; 
		!value

	let goodRandomInt upper pred = goodRandom (fun () -> Random.int upper) pred
	
	let gaussRandom mean sigma () = 
	   let x = Random.float 1.0 in 
		 let y = Random.float 1.0 in 
     mean +. sigma *. (cos (2.0 *. 3.141592652589793 *. x )*.sqrt(-.2.0*.log y))

end

open Utility


module ArrayGenome = struct


	(* change a single random location *) 
	let mutatePoint fn genome  =
		let maxIdx = Array.length genome  in  
		let genome' = Array.copy genome in 
		let idx = Random.int maxIdx in 
		genome'.(idx) <- fn genome.(idx); 
		genome' 
	
	(* change a random location which satisfies pred *)
	let mutatePointWhenPred fn pred genome =  
		let maxIdx = Array.length genome - 1 in  
		let genome' = Array.copy genome in 
		let idx = goodRandom (fun () -> Random.int maxIdx) pred in 
		genome'.(idx) <- fn genome.(idx); 
		genome' 

	(* mutates one or more locations with probability prob *)
	let mutate prob fn genome = 
		let genome' = Array.copy genome in
		let didMutate = ref false in 
		for i = 0 to Array.length genome - 1 do 
			if Random.float 1.0 < prob then begin
				genome'.(i) <- fn genome.(i);
				didMutate := true
			end
		done;			 
		if !didMutate then genome' else mutatePoint fn genome 

	(* mutate one or more locations which satisfy pred *)
	let mutateWhenPred prob fn pred genome =
		let genome' = Array.copy genome in
		let didMutate = ref false in 
		for i = 0 to Array.length genome - 1 do 
			if Random.float 1.0 < prob && pred i then begin
				genome'.(i) <- fn genome.(i);
				didMutate := true
			end
		done;			 
		if !didMutate then genome' else mutatePointWhenPred fn pred genome 

	let transposition genome = 
		let genome' = Array.copy genome in 
		let len = Array.length genome in 
		let idx1 = Random.int len in 
		let idx2 = Utility.randIntExcept len idx1 in 
		let tmp = genome.(idx1) in 
		genome'.(idx1) <- genome.(idx2); 
		genome'.(idx2) <- tmp; 
		genome'

	let onePointCrossover (g1, g2) = 
		let g1Len = Array.length g1 in
		let g2Len = Array.length g2 in  
		let minLen = min g1Len g2Len  in  
		let start = Random.int (minLen-1)  in   
		let gNew = Array.copy g1 in
		Array.blit g2 start gNew start (g1Len - start); 
		gNew 

	let twoPointCrossover (g1, g2) = 
		let g1Len = Array.length g1 in
		let g2Len = Array.length g2 in  
		let minLen = min  g1Len g2Len  in  
		let randLen = 1 + Random.int  (minLen-1) in 
		let start = if randLen < minLen then Random.int (minLen - randLen + 1) else 0   in
		let gNew = Array.copy g1 in
		Array.blit g2 start gNew start randLen; 
		gNew 

	let randomCrossover (g1, g2) =
		let g1Len = Array.length g1 in
		let g2Len = Array.length g2 in  
		let minLen = (min g1Len g2Len) in  
		let randLen = 1 + Random.int  (minLen- 1) in 
		let start1 = if randLen < g1Len then Random.int (g1Len - randLen + 1)  else 0 in     
		let start2 = if randLen < g1Len then Random.int (g2Len - randLen + 1)  else 0 in  
		let gNew = Array.copy g1 in
		Array.blit g2 start2 gNew start1 randLen; 
		gNew 

	let mkArray len fn () = Array.init len (fun _ -> fn ())

end
